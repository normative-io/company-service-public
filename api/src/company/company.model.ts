import { ApiProperty } from '@nestjs/swagger';
import { v4 as uuid } from 'uuid';
import { isEqual, omit } from 'lodash';
import { InsertOrUpdateDto } from './dto/insert-or-update.dto';

// A Company represents a record of the state of a commercial entity at a given point in time.
//
// There are two internal identifiers that are generated by the system and are
// important for a Company object:
// - `id` is globally unique: different Company objects will always have different values.
// - `companyId` groups different Company objects together as belonging to the same commercial entity.
//
// The list of statuses of a commercial entity over time will be a list of Company objects
// that share the same `companyId`.
export class Company {
  // Use `newId()` to generate.
  @ApiProperty({
    type: String,
    description: 'The internal identifier of this record. Defaults to a randomly generated value',
    example: '123456',
  })
  public id: string;

  @ApiProperty({
    type: Boolean,
    description: 'If true, this company record was marked as deleted',
  })
  public isDeleted?: boolean;

  @ApiProperty({
    type: String,
    description: 'The name of the company',
    example: 'An awesome company',
  })
  public companyName: string;

  @ApiProperty({
    description: 'The country code that this company is registered in.',
    example: 'CH',
  })
  public country?: string;

  // Use `newCompanyId()` to generate.
  @ApiProperty({
    description:
      'The internal identifier of the commercial entity this record belongs to. Defaults to a randomly generated value',
    example: '12345abcde',
  })
  public companyId: string;

  @ApiProperty({
    description: 'The Tax ID for the company',
    example: '123',
  })
  public taxId?: string;

  @ApiProperty({
    description: 'The Org Nbr for the company. This is a local identifier, use in conjunction with the country',
    example: '123',
  })
  public orgNbr?: string;

  @ApiProperty({
    description: 'The International Standard Industrial Classification (ISIC) for the company',
    example: '123',
  })
  public isic?: string;

  @ApiProperty({
    type: Date,
    description: 'The date the company was added to the service. Defaults to the current date',
  })
  public created: Date;

  @ApiProperty({
    type: Date,
    description: "The most recent date this company's metadata was changed or verified.",
  })
  public lastUpdated: Date;

  @ApiProperty({
    type: String,
    description: 'Where this company metadata was sourced from.',
  })
  readonly dataSource?: string;

  constructor(insertOrUpdateDto: InsertOrUpdateDto, companyId: string) {
    this.companyId = companyId;

    this.id = Company.newId();
    this.companyName = insertOrUpdateDto.companyName;
    this.country = insertOrUpdateDto.country;
    this.taxId = insertOrUpdateDto.taxId;
    this.orgNbr = insertOrUpdateDto.orgNbr;
    this.isic = insertOrUpdateDto.isic;
    this.dataSource = insertOrUpdateDto.dataSource;
    const now = new Date();
    this.created = now;
    this.lastUpdated = now;
  }

  private static newId(): string {
    return uuid();
  }

  static newCompanyId(): string {
    return uuid();
  }

  // Compares whether two Company objects represent the equivalent metadata.
  isMetadataEqual(other: Company): boolean {
    const internalFields = ['id', 'created', 'lastUpdated'];
    return isEqual(omit(this, internalFields), omit(other, internalFields));
  }

  private static equalStringField(field1: string, field2: string) {
    return !field1 || !field2 || field1 == field2;
  }

  // isSameEntity returns whether the current company and the given company are the same commercial entity,
  // and, if they are not, why.
  // Two companies are not considered the same entity if they have different values of identifiers, country,
  // or companyId.
  // We assume that the current company is a new company we're trying to create, and the argument is the
  // existing one in the system. This is an arbitrary decision, and the result of the method would be the same
  // if it was the other way around, but this assumption allows to return a more descriptive message.
  isSameEntity(existing: Company): [boolean, string] {
    if (!Company.equalStringField(this.companyId, existing.companyId)) {
      return [false, `Conflicting companyId: new: ${this.companyId}, existing: ${existing.companyId}`];
    }
    if (!Company.equalStringField(this.taxId, existing.taxId)) {
      return [false, `Conflicting taxId: new: ${this.taxId}, existing: ${existing.taxId}`];
    }
    if (!Company.equalStringField(this.country, existing.country)) {
      return [false, `Conflicting country: new: ${this.country}, existing: ${existing.country}`];
    }
    if (!Company.equalStringField(this.orgNbr, existing.orgNbr)) {
      return [false, `Conflicting orgNbr: new: ${this.orgNbr}, existing: ${existing.orgNbr}`];
    }

    return [true, ''];
  }
}
